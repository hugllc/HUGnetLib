<?php
/**
 * Tests the filter class
 *
 * PHP Version 5
 *
 * <pre>
 * HUGnetLib is a library of HUGnet code
 * Copyright (C) 2007-2010 Hunt Utilities Group, LLC
 * Copyright (C) 2009 Scott Price
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * </pre>
 *
 * @category   Filters
 * @package    HUGnetLibTest
 * @subpackage Filters
 * @author     Scott Price <prices@hugllc.com>
 * @copyright  2007-2010 Hunt Utilities Group, LLC
 * @copyright  2009 Scott Price
 * @license    http://opensource.org/licenses/gpl-license.php GNU Public License
 * @version    SVN: $Id$
 * @link       https://dev.hugllc.com/index.php/Project:HUGnetLib
 *
 */

require_once dirname(__FILE__).'/../filter.php';
require_once dirname(__FILE__).'/../lib/plugins.inc.php';
require_once dirname(__FILE__).'/filterMocks.php';

/**
 * Test class for filter.
 * Generated by PHPUnit_Util_Skeleton on 2007-10-30 at 08:44:56.
 *
 * @category   Filters
 * @package    HUGnetLibTest
 * @subpackage Filters
 * @author     Scott Price <prices@hugllc.com>
 * @copyright  2007-2010 Hunt Utilities Group, LLC
 * @copyright  2009 Scott Price
 * @license    http://opensource.org/licenses/gpl-license.php GNU Public License
 * @link       https://dev.hugllc.com/index.php/Project:HUGnetLib
 */
class FilterTest extends PHPUnit_Framework_TestCase
{
    /**
     * Runs the test methods of this class.
     *
     * @return null
     *
     * @access public
     * @static
     */
    public static function main()
    {
        include_once "PHPUnit/TextUI/TestRunner.php";

        $suite  = new PHPUnit_Framework_TestSuite("filterTest");
        $result = PHPUnit_TextUI_TestRunner::run($suite);
    }

    /**
     * Sets up the fixture, for example, open a network connection.
     * This method is called before a test is executed.
     *
     * @return null
     *
     * @access protected
     */
    protected function setUp()
    {
        $this->o = new filter();
    }

    /**
     * Tears down the fixture, for example, close a network connection.
     * This method is called after a test is executed.
     *
     * @return null
     *
     * @access protected
     */
    protected function tearDown()
    {
        unset($this->o);
    }

    /**
     * dataProvider for testRegisterFilter
     *
     * @return array
     */
    public static function dataRegisterFilter()
    {
        return array(
            array("testFilter", true),
            array("testFilterBad", false),
            array("testFilterNoFilters", false),
        );
    }
    /**
     * test
     *
     * @param string $class  The class register
     * @param bool   $expect What to expect from the return
     *
     * @return null
     *
     * @dataProvider dataRegisterFilter
     */
    public function testRegisterFilter($class, $expect)
    {
        $ret = $this->o->registerFilter($class);
        $this->assertSame($expect, $ret);
        if ($expect) {
            $this->assertThat(
                $this->o->filters[$class],
                $this->isInstanceOf($class)
            );
            foreach ($this->o->filters[$class]->filters as $type => $sInfo) {
                foreach ($sInfo as $filter => $val) {
                    $this->assertSame(
                        $this->o->dev[$type][$filter],
                        $class,
                        "'$type->$filter': Not found"
                    );
                }
            }
        }
    }
    /**
     * dataProvider for testFilter
     *
     * @return array
     */
    public static function dataFilter()
    {
        return array(
            array(
                array(1,2,3,4,5,6),
                array("testFilter1"),
                array(),
                array(6,5,4,3,2,1),
            ),
        );
    }

    /**
     * test
     *
     * @param array $history The history to filter
     * @param array $filters The array of filters to use
     * @param mixed $extra   Extra stuff for the filter
     * @param array $expect  What to expect from the return
     *
     * @return null
     *
     * @dataProvider dataFilter
     */
    public function testFilter($history, $filters, $extra, $expect)
    {
        $this->o->registerFilter("testFilter");
        $this->o->filter($history, $filters, $extra);
        $this->assertSame($expect, $history);
    }

    /**
     * test
     *
     * @return null
     */
    public function testRunFunctionCall()
    {
        $cName = "testFilter";
        $this->o->registerFilter($this->getMock($cName), $cName);
        $this->o->filters[$cName]->expects($this->once())
            ->method('test1')
            ->with(
                $this->equalTo(1),
                $this->equalTo(2),
                $this->equalTo(3),
                $this->equalTo(4)
            );
        $args = array(1,2,3,4);
        $ret = $this->o->runFunction($this->o->filters[$cName], 'test1', $args, "2");
    }

    /**
     * data provider
     *
     * @return array
     */
    public static function dataRunFunction()
    {
        return array(
            array("testFilter", "Test1", array(array(2,1,0),2,3,4,), array(0,1,2)),
            array(
                "testFilter",
                "badFunction",
                array(array(1,2,3),2,3,4),
                array(1,2,3)
            ),
            array("badClass", "Test1", array(array(1),2,3,4), array(1)),
        );
    }
    /**
     * test
     *
     * @param string $class    The class to use
     * @param string $function The function to call
     * @param array  $args     The arguments for the function
     * @param mixed  $expect   What to expect from the return
     *
     * @return null
     *
     * @dataProvider dataRunFunction
     */
    public function testRunFunction($class, $function, $args, $expect)
    {
        $this->o->registerFilter($class);
        $this->o->runFunction($this->o->filters[$class], $function, $args);
        // The history is modified in $args[0];
        $this->assertSame($expect, $args[0]);
    }

    /**
     * data provider
     *
     * @return array
     */
    public static function dataGetClass()
    {
        return array(
            array("testType", "", "sameClass", "testType", "testFilter1"),
            array("testType", "testFilter2", "sameClass", "testType", "testFilter2"),
            array("badType", "testFilter2", "sameClass", "testType", "testFilter2"),
            array("badType", "badFilter", null, "badType", "badFilter"),
        );
    }
    /**
     * test
     *
     * @param string $type         The type of filter
     * @param string $filter       The filter to implement.  This can be changed
     *                                 by this routine.
     * @param string $expect       What to expect from the return
     * @param string $typeExpect   The type of filter
     * @param string $filterExpect The filter to implement.  This can be changed
     *                                 by this routine.
     *
     * @return null
     *
     * @dataProvider dataGetClass().
     */
    public function testGetClass($type, $filter, $expect, $typeExpect, $filterExpect)
    {
        $cName = "testFilter";
        $this->o->registerFilter($cName);
        $class = $this->o->getClass($type, $filter);
        if ($expect === "sameClass") {
            $expect = $this->o->filters[$cName];
        }
        $this->assertSame($class, $expect, "Wrong object returned");
        $this->assertEquals($type, $typeExpect, "Type changed incorrectly");
        $this->assertEquals($filter, $filterExpect, "Sensor changed incorrectly");
    }

}

?>
