<?php
/**
 *   Tests the EPacket class
 *
 *   <pre>
 *   HUGnetLib is a library of HUGnet code
 *   Copyright (C) 2007 Hunt Utilities Group, LLC
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public License
 *   as published by the Free Software Foundation; either version 3
 *   of the License, or (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *   </pre>
 *
 *   @license http://opensource.org/licenses/gpl-license.php GNU Public License
 *   @package HUGnetLib
 *   @subpackage Test
 *   @copyright 2007 Hunt Utilities Group, LLC
 *   @author Scott Price <prices@hugllc.com>
 *   @version $Id$
 *
 */

// Call EPacketTest::main() if this source file is executed directly.
if (!defined("PHPUnit_MAIN_METHOD")) {
    define("PHPUnit_MAIN_METHOD", "EPacketTest::main");
}

require_once "PHPUnit/Framework/TestCase.php";
require_once "PHPUnit/Framework/TestSuite.php";

require_once dirname(__FILE__).'/../EPacket.php';
require_once dirname(__FILE__).'/../epsocket.php';

/**
 * Test class for EPacket.
 * Generated by PHPUnit_Util_Skeleton on 2007-10-30 at 08:45:46.
 */
class EPacketTest extends PHPUnit_Framework_TestCase {
    /** 
     * Test packets in array form 
     *
     * This array needs to have the same keys as $testPacketStr and $testPacketReplyStr     
     * @see EPacketTest::testPacketStr, EPacketTest::testPacketReplyStr    
     */
    var $testPacketArray = array(
        array(
            "Command" => "55",
            "To" => "ABC",
            "From" => "000020",
            "Data" => "01020304",
            "RawData" => "01020304",
            "Length" => 4,
            "Checksum" => "C3",
        ),
        array(
            "Command" => "5C",
            "To" => "000ABC",
            "From" => "000020",
            "RawData" => "",
            "Length" => 0,
            "Checksum" => "CA",
        ),
        array(
            "Command" => "5C",
            "To" => "ABCDEF12345",
            "From" => "000020",
            "RawData" => "",
            "Length" => 0,
            "Checksum" => "F5",
        ),
    );
    /** 
     * Test packets in array form 
     *
     * This array needs to have the same keys as $testPacketStr and $testPacketReplyStr     
     * @see EPacketTest::testPacketStr, EPacketTest::testPacketReplyStr    
     */
    var $testPacketReplyArray = array(
        array(
            "Command" => "01",
            "To" => "000020",
            "From" => "000ABC",
            "Data" => "01020304",
            "Length" => 4,
            "Checksum" => "97",
        ),
        array(
            "Command" => "01",
            "From" => "000ABC",
            "To" => "000020",
            "Data" => "",
            "Length" => 0,
            "Checksum" => "97",
        ),
        array(
            "Command" => "01",
            "From" => "ABCDEF",
            "To" => "000020",
            "Data" => "",
            "Length" => 0,
            "Checksum" => "A8",
        ),
    );
    /** 
     *   Test Packets in string form 
     *
     * This array needs to have the same keys as $testPacketArray and $testPacketReplyStr     
     * @see EPacketTest::testPacketReplyStr, EPacketTest::testPacketArray    
     */
    var $testPacketStr = array(
        "5A5A5A55000ABC0000200401020304C3",
        "5A5A5A5C000ABC00002000CA",
        "5A5A5A5CABCDEF00002000F5",
    );
    /** 
     * Test Packets in string form 
     *
     * This array needs to have the same keys as $testPacketStr and $testPacketArray
     * @see EPacketTest::testPacketStr, EPacketTest::testPacketArray    
     */
    var $testPacketReplyStr = array(
        "5A5A5A01000020000ABC040102030497",
        "5A5A5A01000020000ABC0097",
        "5A5A5A01000020ABCDEF00A8",
    );
    /**
     * Runs the test methods of this class.
     *
     * @access public
     * @static
     */
    public static function main() {
        require_once "PHPUnit/TextUI/TestRunner.php";

        $suite  = new PHPUnit_Framework_TestSuite("EPacketTest");
        $result = PHPUnit_TextUI_TestRunner::run($suite);
    }

    /**
     * Sets up the fixture, for example, open a network connection.
     * This method is called before a test is executed.
     *
     * @access protected
     */
    protected function setUp() {
    }

    /**
     * Tears down the fixture, for example, close a network connection.
     * This method is called after a test is executed.
     *
     * @access protected
     */
    protected function tearDown() {
    }

    private function deHexifyArray($string) {
        $index = 0;
        $array = array();
        while (($index * 2) < strlen($string)) {
            $array[$index] = chr(hexdec(substr($string, $index * 2, 2)));
        }
    }

    /**
     *
     */
    private function cleanTo($to) {
        $to = trim($to);
        $to = substr($to, 0, 6);
        $to = str_pad($to, 6, "0", STR_PAD_LEFT);
        $to = strtoupper($to);
    
        return $to;
    }
    /**
     *
     */
    public function validPacketArray($a, $test=NULL, $keys = NULL) {
        $this->assertTrue(is_array($a), "This is not an array!");
        $this->assertTrue(is_string($a['Command']), "'".$a['Command']."': Packet command must be a string");
        $this->assertEquals(2, strlen($a['Command']), "'".$a['Command']."': Packet command must contain exactly 2 characters");
        $this->assertTrue(is_string($a['To']), "'".$a['To']."': Packet to must be a string");
        $this->assertEquals(6, strlen($a['To']), "'".$a['To']."': Packet to must contain exactly 6 characters");
        if (is_array($test)) {
            foreach($test as $key => $var) {
                // Check to see if the key was specified
                if (is_array($keys)) {
                    // If it was not continue.
                    if (array_search($key, $keys) === FALSE) continue;
                    // Drop through if it was specified, or if nothing was specified.
                }
                if (trim(strtolower($key)) == "to") {
                    $var = $this->cleanTo($var);
                }
                $this->assertEquals($var, $a[$key], "'$key' field is not the same");
            }
        }
    }
    /**
     *
     */
    public function validPacketString($s, $a=NULL) {
        $this->assertTrue(is_string($s), "This is not a string!");
        $s = strtoupper($s);
        $preambleLength = EPacketTest::getPreambleLength($s);
        $this->assertTrue((($preambleLength >= 2) && ($preambleLength <= 3)), "Preamble must be 2 or 3 characters");
        $length = hexdec(substr($s, ($preambleLength + 7) * 2, 2));
        $totalLength = $preambleLength + 8 + $length + 1;
        $this->assertEquals(($totalLength * 2), strlen($s), count($a['command']), "Packet command must contain exactly 2 characters");
        if (is_array($a)) {
            $a = array_change_key_case($a, CASE_LOWER);
            $to = $this->cleanTo($a["to"]);
            $pTo = substr($s, ($preambleLength+1) * 2, 6);
            $this->assertEquals($to, $pTo, "To field is Wrong.  '$to' != '$pTo'");
            $this->assertEquals($length * 2, strlen(trim($a['data'])), "Wrong length parameter.");
        }
    }
    /**
     *
     */
    public function getPreambleLength($pkt) {
        $length = 0;
        while (substr($pkt, ($length*2), 2) == "5A") $length++;    
        return $length;
    }

    /**
     * @todo Implement testPacketBuild().
     */
    public function testPacketBuild() {
        $o = new EPacket();
        foreach($this->testPacketArray as $p) {
            $pkt = $o->PacketBuild($p);
            $this->validPacketString($pkt, $p);
        }
    }

    /**
     * @todo Implement testDeHexify().
     */
    public function testDeHexify() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testPacketGetChecksum().
     */
    public function testPacketGetChecksum() {
        $o = new EPacket();
        foreach($this->testPacketStr as $s) {
            // Remove preamble
            $preambleLength = $this->getPreambleLength($s);
            $s = substr($s, ($preambleLength * 2));
            $cCksum = substr($s, -2);
            $s = substr($s, 0, strlen($s)-2);
            $cksum = $o->PacketGetChecksum($s);
            $this->assertEquals(strtoupper(trim($cksum)), $cCksum, "Checksum mismatch on '$s'.  '$cksum' != '$cCksum'");
        }
    }

    /**
     * @todo Implement testBuildPacket().
     */
    public function testBuildPacket() {
        $o = new EPacket();
        $testData = array(
            array("123", "AB", "12345678"),
            array("3456", "CD"),
        );
        foreach($testData as $t) {
            if (isset($t[2])) {
                $pkt = $o->buildPacket($t[0], $t[1], $t[2]);
            } else {
                $pkt = $o->buildPacket($t[0], $t[1]);
            }
            $this->assertEquals($pkt['Command'], $t[1], "Command not set correctly");
            $this->assertEquals($pkt['To'], $t[0], "To not set correctly");
            $this->assertEquals($pkt['Data'], $t[2], "Data not set correctly");
        }
    }

    /**
     * @todo Implement testPacketSetCallBack().
     */
    public function testPacketSetCallBackMethod() {
        $o = new EPacket();
        $t = new EPacketTest_CallBack_Class();
        $o->PacketSetCallBack("Test", $t);
        $this->assertEquals($o->callBackFunction, "Test", "Method not saved correctly");
        $this->assertTrue(is_object($o->callBackObject), "Class not saved correctly");
        $this->assertEquals(get_class($o->callBackObject), "EPacketTest_CallBack_Class", "Class not saved correctly");
    }

    /**
     * @todo Implement testPacketSetCallBack().
     */
    public function testPacketSetCallBackFunction() {
        $o = new EPacket();
        $o->PacketSetCallBack("EPacketTest_CallBack_Function");
        $this->assertEquals($o->callBackFunction, "EPacketTest_CallBack_Function", "Function not saved correctly");
        $this->assertTrue(is_null($o->callBackClass), "Class not saved correctly");
    }

    /**
     * @todo Implement testPacketCallBack().
     */
    public function testPacketCallBackMethod() {
        $o = new EPacket();
        $t = $this->getMock('EPacketTest_CallBack_Class');
        $string = "ABCDE";
        $t->expects($this->once())
          ->method('Test')
          ->with($this->equalTo($string));
        $o->PacketSetCallBack("Test", $t);
        $o->PacketCallBack($string);
    }
    /**
     * @todo Implement testPacketCallBack().
     */
    public function testPacketCallBackFunction() {
        $o = new EPacket();
        $string = "ABCDE";
        /**
         * This function is for testing callback
         */
        function EPacketTest_CallBack_Function($pkt) {
            $_SESSION['EPacketTest_CallBack_Function'] = $pkt;
        }

        $o->PacketSetCallBack("EPacketTest_CallBack_Function");
        $o->PacketCallBack($string);
        $this->assertEquals($_SESSION['EPacketTest_CallBack_Function'], $string);
    }

    /**
     * @todo Implement testSendPacket().
     */
    public function testSendPacketSocket() {
        $o = new EPacket();
        $o->socket[1] = new epsocketMock();
        $Info = array("GatewayKey" => 1);
        foreach($this->testPacketStr as $key => $data) {
            $o->socket[1]->setReply($data, $this->testPacketReplyStr[$key]);
        }
        foreach($this->testPacketArray as $key => $val) {
            $val['To'] = $this->cleanTo($val['To']);
            $rep = $o->SendPacket($Info, array($val), TRUE, NULL);
            $this->assertTrue(is_array($rep), "Packet '".$this->testPacketReplyStr[$key]."' not returned correctly");
            $this->validPacketArray($rep[0], $this->testPacketReplyArray[$key], array("Command", "To", "Checksum", "From"));
        }
    }
    /**
     * @todo Implement testSendPacket().
     */
    public function testSendPacketWriteSocket() {
        $o = new EPacket();
        $Info = array("GatewayKey" => 1);
        $o->socket[1] = $this->getMock('epsocketMock');
        $o->socket[1]->expects($this->exactly(2))
                     ->method('Write')
                     ->with($this->equalTo(EPacket::deHexify($this->testPacketStr[0])));
        $rep = $o->SendPacket($Info, array($this->testPacketArray[0]), FALSE, NULL);
    }

    /**
     * @todo Implement testSendPacket().
     */
    public function testSendPacketWriteRetry() {
        $o = new EPacket();
        $Info = array("GatewayKey" => 1);
        $o->Retries = 4;
        $o->socket[1] = $this->getMock('epsocketMock');
        $o->socket[1]->expects($this->any())
                     ->method('Write')
                     ->with($this->equalTo(EPacket::deHexify($this->testPacketStr[0])));
        $rep = $o->SendPacket($Info, array($this->testPacketArray[0]), FALSE, NULL);
    }

    /**
     * @todo Implement testSendReply().
     */
    public function testSendReply() {
        $o = new EPacket();
        $Info = array("GatewayKey" => 1);
        $o->socket[1] = $this->getMock('epsocketMock');
        $o->socket[1]->expects($this->exactly($o->Retries))
                     ->method('Write')
                     ->with($this->equalTo(EPacket::deHexify("5A5A5A01000ABC000020040102030497")));
        $rep = $o->SendReply($Info, "000ABC", "01020304");
    }

    /**
     * @todo Implement testArrayToData().
     */
    public function testArrayToDataValid() {
        $o = new EPacket();
        $s = $o->arrayToData(array(1,2,3,4,5));
        $this->assertEquals($s, "0102030405", "Doesn't take arrays well");
        $s = $o->arrayToData("0102030405");
        $this->assertEquals($s, "0102030405", "Doesn't take strings well");
        $s = $o->arrayToData(array());
        $this->assertEquals($s, "", "Doesn't take blank arrays well");
    }
    /**
     * Test calling it directly
     */
    public function testArrayToDataDirect() {
        $s = EPacket::arrayToData(array(1,2,3,4,5));
        $this->assertEquals($s, "0102030405", "Doesn't take arrays well");
        $s = EPacket::arrayToData("0102030405");
        $this->assertEquals($s, "0102030405", "Doesn't take strings well");
        $s = EPacket::arrayToData(array());
        $this->assertEquals($s, "", "Doesn't take blank arrays well");

    }
    /**
     * @todo Implement testArrayToData().
     */
    public function testArrayToDataInvalid() {
        $o = new EPacket();
        $s = $o->arrayToData(array());
        $this->assertEquals($s, "");
        $s = $o->arrayToData(NULL);
        $this->assertEquals($s, "");
        $s = $o->arrayToData(45);
        $this->assertEquals($s, "");
    }

    /**
     * @todo Implement testChangeSN().
     */
    public function testChangeSN() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testPacketTime().
     */
    public function testPacketTime() {
        $t = EPacket::PacketTime();
        $this->assertTrue(is_float($t), "Time not a floating point number");
    }

    /**
     * @todo Implement testRecvPacket().
     */
    public function testRecvPacket() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_RecvPacket_Indirect().
     */
    public function test_RecvPacket_Indirect() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_RecvPacket_Socket().
     */
    public function test_RecvPacket_Socket() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testIsGateway().
     */
    public function testIsGateway() {
        $o = new EPacket();
        $this->assertTrue($o->isGateway("000010"), "Doesn't take strings well inside range");
        $this->assertTrue($o->isGateway(10), "Doesn't take integers well inside range");
        $this->assertFalse($o->isGateway("FFFFFF"), "Doesn't take strings well above range");
        $this->assertFalse($o->isGateway(0xFFFFFF), "Doesn't take integers well above range");
        $this->assertFalse($o->isGateway(-1), "Doesn't take integers well below range");
    }

    /**
     * @todo Implement testGetAll().
     */
    public function testGetAll() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testInterpPacket().
     */
    public function testInterpPacket() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testUnbuildPacket().
     */
    public function testUnbuildPacket() {
        $check = array("Command", "To", "From", "RawData", "Checksum", "Length");
        $o = new EPacket();
        foreach($this->testPacketStr as $key => $str) {
            $pkt = $o->unbuildPacket($str);
            $this->validPacketArray($pkt, $this->testPacketArray[$key], $check);
        }
    }

    /**
     * @todo Implement testGetUnsolicited().
     */
    public function testGetUnsolicited() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testMonitor().
     */
    public function testMonitor() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testPing().
     */
    public function testPing() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testFindDevice().
     */
    public function testFindDevice() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testConnect().
     *
    public function testConnect() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testClose().
     */
    public function testClose() {
        $o = new EPacket();
        $o->socket[1] = $this->getMock('epsocketMock');
        $o->socket[1]->expects($this->once())
                     ->method('Close');
        $Info = array("GatewayKey" => 1);
        $rep = $o->Close($Info);
    }

    /**
     * @todo Implement testHexify().
     */
    public function testHexify() {
        $this->assertEquals(EPacket::hexify(1), "01");
        $this->assertEquals(EPacket::hexify(-1,4), "FFFF");
        $this->assertEquals(EPacket::hexify(1024,2), "00");
        $this->assertEquals(EPacket::hexify(1024,4), "0400");
    }

    /**
     * @todo Implement testHexifyStr().
     */
    public function testHexifyStr() {
        $this->assertEquals(EPacket::hexifyStr("\0\r\n"), "000D0A");
        $this->assertEquals(EPacket::hexifyStr("123"), "313233");
        $this->assertEquals(EPacket::hexifyStr("ABC"), "414243");
    }

    /**
     * @todo Implement testSNCheck().
     */
    public function testSNCheck() {
        $o = new EPacket();
        // This is repeated twice on purpose.
        $o->SNCheck(FALSE);
        $this->assertFalse($o->_DeviceIDCheck);
        $o->SNCheck(TRUE);
        $this->assertTrue($o->_DeviceIDCheck);
        $o->SNCheck(FALSE);
        $this->assertFalse($o->_DeviceIDCheck);
        $o->SNCheck(TRUE);
        $this->assertTrue($o->_DeviceIDCheck);
    }
}

// Call EPacketTest::main() if this source file is executed directly.
if (PHPUnit_MAIN_METHOD == "EPacketTest::main") {
    EPacketTest::main();
}

/**
 * This class is for testing callback
 */
class EPacketTest_CallBack_Class {
/**
 * This function is for testing callback
 */
    public function Test($pkt) {
        $this->TestVar = $pkt;
    }
}

/**
 * This class overrides epsocket so that we can test EPacket without
 * actually using a socket connection.
 */
class epsocketMock extends epsocket {

    var $socket = FALSE;
    var $index = 0;

    public function setReply($data, $reply) {
        $this->reply[trim($data)] = trim($reply);
    }    
    /**
     *
     */
    public function Connect($server = "", $port = 0, $timeout=0) {
        $return = FALSE;
        if ($this->CheckConnect()) {
            $return = TRUE;
        } else {
            $this->Close();
        }
        if ($return === FALSE) {
            if (!empty($server)) $this->Server = $server;
            if (!empty($port)) $this->Port = $port;

            if (!empty($this->Server) && !empty($this->Port)) {
                $this->socket = TRUE;
                $return = TRUE;
            } else {
                $this->Errno = -1;
                $this->Error = "No server specified";
                $return = FALSE;
            }
        }        
        return($return);

    }
    /**
     *
     */
    function CheckConnect() {
        return $this->socket;
    }

    /**
     *
     */
    function Close() {
        $this->socket = FALSE;
    }

    /**
     *
     */
    function readChar($timeout=-1) {
        if ($timeout < 0) $timeout = $this->PacketTimeout;
        
        $char = FALSE;
        if (($this->index == 0) && (!empty($this->lastPacket))) {
            if (is_string($this->reply[$this->lastPacket])) {
                $char = chr(hexdec(substr($this->reply[$this->lastPacket], $this->index, 2)));
                $this->index+=2;
            }
        } else {
            if ($this->index < strlen($this->reply[$this->lastPacket])) { 
                $char = chr(hexdec(substr($this->reply[$this->lastPacket], $this->index, 2)));
                $this->index+=2;
            } else {
                $this->index = 0;
                $this->lastPacket = "";
            }
        }
        return $char;
    }
    /**
     *
     */
    function Write($data) {
        $this->lastPacket = EPacket::hexifyStr($data);
        $this->index = 0;
        return TRUE;
    }

}

?>
